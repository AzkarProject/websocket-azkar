<!DOCTYPE HTML>
<html>

<head>
    <link rel="stylesheet" href="/css/style.css" />
</head>

<body onload="init();">
    <p>
        Les dimensions de la carte doivent correspondre aux dimensions de la carte du robot :
        <div id="dim"></div>
    </p>
    <div id="map" style="float: right">
        <canvas id="canvasMap" width="200" height="200" style="
                                background:  no-repeat;
                                background-image:url('/images/Map.png');
                                background-position-x:0px;
                                background-position-y:0px;
                                "></canvas>
    </div>
    <button onclick="getDataMap();">Click me</button>
    <script>
    var type = "pilote-appelant";
    var otherType = "pilote-appelé";
    </script>
    <script src="http://code.jquery.com/jquery-1.10.1.min.js"></script>
    <script src="/socket.io/socket.io.js"></script>
    <script src="/js/common.js"></script>
    <script src="/js/settings.js"></script>
    <script src='/js/mapviewer.js'></script>
    <script src='/js/ws_manager.js'></script>
    <script src='/js/commands.js'></script>
    <script src='/js/main.js'></script>
    <script>
    var canvasMap = document.getElementById("canvasMap");
    var context = canvasMap.getContext("2d");


    function init() {
        var offsetX, offsetY, corrOffestX, corrOffestY;

        $.get("http://192.168.173.1:8080/?url=http://127.0.0.1:50000/nav/maps/parameters", function(dataMap) {
            console.log('lalala', dataMap);
            if (!dataMap)
                return "pas de données ! :/ ";

            //  mapInfo = JSON.parse(dataMap);
            //get the map width and height to adjust the canvas

            offsetX = dataMap.Offset.X;
            offsetY = dataMap.Offset.Y;

            corrOffestX = dataMap.Height - (dataMap.Resolution * offsetX);
            corrOffestY = dataMap.Width - (dataMap.Resolution * offsetY);

            /****************essai de trouver le 0,0 ************************/
            context.beginPath();
            context.arc(corrOffestX, corrOffestY, 10, 0, 2 * Math.PI, false);
            context.fillStyle = 'green';
            context.fill();
            context.lineWidth = 3;
            context.strokeStyle = '#003300';
            context.stroke();
            /***************************************************************/
            $('#canvasMap').attr("width", dataMap.Width);
            $('#canvasMap').attr("height", dataMap.Height);

            console.log("Dimension Width : " + dataMap.Width + ",  Height : " + dataMap.Height);
            console.log('lalala 2 ');
            if (document.getElementById("dim")) {
                //text info
                var text = "height : " + dataMap.Height + "px  width : " + dataMap.Width + "px";
                document.getElementById("dim").innerHTML = text;
                console.log('lalala 3 ');
            }
        });
    }


    /* /** refresh 
     * every 600 ms 
     * 1) refresh the status  :   - recuperer le status du robot --> requete get sur url ???
     *                            - mettre à jour son status --> checkRobotStatus() ;
     *                            
     * 2)clean the canvas
     * 3)recheck the robot position  : recuperer la position du robot --> requete get sur url ?? 
     * 4)dessiner la position du robot sur le canvas --> drawRobot(x,y) 
     * 5) redraw locations point
     * */
    function refresh() {
        /*setInterval(function() {
                $.get(ipServlet + 'mapServlet?localization=1', function(dataLocalization) {
                    robotInfo = JSON.parse(dataLocalization);
                });
                $.get(ipServlet + 'mapServlet?status=1', function(data) {
                    robotStatus = JSON.parse(data);
                });


                checkRobotStatus();
                context.clearRect(0, 0, canvasMap.width, canvasMap.height);
                //recalcul the locations (only on admin.jsp            

                initLocationsPoints();

                drawLocationsPoints();
                context.beginPath();
                drawRobot();

            }, 600); */
    }



    //check robot status
    // null => offline
    //0 waiting gotopoint or gotopose request
    //1 waiting move request 
    //2 moving
    function checkRobotStatus() {
        /*
        var bool = robotStatus || 0;
        if(bool){
            if(robotStatus.Status >=0 ){
                if(co==0){
                    $('.statusCo').empty();
                    $('.statusCo').css("color", "#00FF00")
                    $('.statusCo').append("Online"); 
                    $('.status').empty();
                }
                co=1;                              
            }
            else{                  
                $("#status").hide();
                $('.status').empty();
                $('.statusCo').empty();
                $('.statusCo').append("Offline"); 
                $('.statusCo').css("color", "#FF0000");
                co =0;                
            }
        }          
        else {
            $('.status').empty();
            $('.statusCo').empty();
            $('.statusCo').append("Offline"); 
            $('.statusCo').css("color", "#FF0000");
            co =0;
        }   
        */
    }


    //calculate x , y and theta 
    // then draw it 
    function drawRobot() {
        /*
        var rx = robotInfo.Pose.Position.Y * mapInfo.Resolution +corrOffestY ;
        var ry = robotInfo.Pose.Position.X * mapInfo.Resolution + corrOffestX;
        var qw = robotInfo.Pose.Orientation.W;
        var qz = robotInfo.Pose.Orientation.Z;
        var heading =0;
        var attitude = 0 ;
        var qx = 0;
        var qy = 0;
        var qy2 = qy*qy;
        var qz2 = qz*qz;
        var test= qx*qy + qz*qw;
        if (test > 0.499) {
            heading = 360/Math.PI*Math.atan2(qx,qw);
            attitude = 90;
            return;
        }
        if (test < -0.499) {
            heading = -360/Math.PI*Math.atan2(qx,qw);
            attitude = -90;
            return;
        }
        heading= Math.atan2(2*qy*qw-2*qx*qz,1-2*qy2-2*qz2);
        attitude= Math.asin(2*qx*qy+2*qz*qw);
        var angle = (heading==0)? angle= -attitude:Math.PI+attitude;
        //draw it 
        circleWithDirection(mapInfo.Width - rx- 2- cropX/2, mapInfo.Height - ry - 2 - cropY/2,  angle- Math.PI/2,"blue",6,4);
        */
    }

    //draw a circle with a line     
    function circleWithDirection(x, y, theta, color, size, sizeStroke) {
        /*
        context.beginPath();
        context.arc(x, y, size, 0, 2 * Math.PI, false);
        context.fillStyle = color;
        context.fill();
        context.lineWidth = 2;
        context.strokeStyle = "black";
        context.stroke();
        x2 = x + Math.cos(theta) * 15;
        y2 = y+ Math.sin(theta)*15;
        context.closePath();    
        context.beginPath();                  
        context.moveTo(x, y);
        context.lineTo(x2, y2);                
        context.strokeStyle = color;
        context.lineCap = "round";
        context.lineWidth = sizeStroke;     
        context.stroke();  
        context.closePath();
        */
    }


    //draw a triangle on canvas at the x y  coordinates 
    //theta is the angle
    function triangle(x, y, theta) {
        /*
        context.stroke();
        context.beginPath();
        context.lineWidth =1;
        context.strokeStyle = "black";
        context.fillStyle = "#00D2FF";
        var size = 15;
        x2 =x + Math.cos(theta) * size;
        y2 = y+ Math.sin(theta)*size;
        context.moveTo(x2, y2);       
        x2 = x + Math.cos(Math.PI*1.15 + theta) * size;
        y2 = y+ Math.sin(Math.PI*1.15 + theta)*size;
        context.lineTo(x2, y2);
        x2 = x + Math.cos(Math.PI + theta) * size/2;
        y2 = y+ Math.sin(Math.PI + theta)*size/2    ;
        context.lineTo(x2, y2);
        x2 = x + Math.cos(Math.PI*0.85  + theta) * size;
        y2 = y+ Math.sin(Math.PI*0.85 + theta)*size ;
        context.lineTo(x2, y2);
        context.closePath();
        context.fill();
        context.stroke();         */
    }
    </script>
</body>

</html>
